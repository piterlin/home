<!DOCTYPE html>
<html>
<head>
<meta charset=utf-8>
<meta name=”viewport” content=”width=device-width; initial-scale=1.0; minimum-scale=1.0; maximum-scale=1.0″/>
    <meta name="apple-mobile-web-app-capable" content="yes" /><!-- home screen app 全屏 -->
    <meta name="apple-mobile-web-app-status-bar-style" content="black" /><!-- 状态栏 -->
<title>jd3x4</title>
<script>
THREE.DeviceOrientationControls = function(object) {

	var scope = this;

	this.object = object;
	this.object.rotation.reorder("YXZ");

	this.enabled = true;

	this.deviceOrientation = {};
	this.screenOrientation = 0;

	var onDeviceOrientationChangeEvent = function(event) {

		scope.deviceOrientation = event;

	};

	var onScreenOrientationChangeEvent = function() {

		scope.screenOrientation = window.orientation || 0;

	};

	// The angles alpha, beta and gamma form a set of intrinsic Tait-Bryan angles of type Z-X'-Y''

	var setObjectQuaternion = function() {

		var zee = new THREE.Vector3(0, 0, 1);

		var euler = new THREE.Euler();

		var q0 = new THREE.Quaternion();

		var q1 = new THREE.Quaternion(-Math.sqrt(0.5), 0, 0, Math.sqrt(0.5)); // - PI/2 around the x-axis

		return function(quaternion, alpha, beta, gamma, orient) {

			euler.set(beta, alpha, -gamma, 'YXZ'); // 'ZXY' for the device, but 'YXZ' for us

			quaternion.setFromEuler(euler); // orient the device

			quaternion.multiply(q1); // camera looks out the back of the device, not the top

			quaternion.multiply(q0.setFromAxisAngle(zee, -orient)); // adjust for screen orientation

		}

	}();

	this.connect = function() {

		onScreenOrientationChangeEvent(); // run once on load

		window.addEventListener('orientationchange', onScreenOrientationChangeEvent,
			false);
		window.addEventListener('deviceorientation', onDeviceOrientationChangeEvent,
			false);

		scope.enabled = true;

	};

	this.disconnect = function() {

		window.removeEventListener('orientationchange',
			onScreenOrientationChangeEvent, false);
		window.removeEventListener('deviceorientation',
			onDeviceOrientationChangeEvent, false);

		scope.enabled = false;

	};

	this.update = function() {

		if ( scope.enabled === false ) return;

		var alpha = scope.deviceOrientation.alpha ? THREE.Math.degToRad(scope.deviceOrientation
			.alpha) : 0; // Z
		var beta = scope.deviceOrientation.beta ? THREE.Math.degToRad(scope.deviceOrientation
			.beta) : 0; // X'
		var gamma = scope.deviceOrientation.gamma ? THREE.Math.degToRad(scope.deviceOrientation
			.gamma) : 0; // Y''
//		var orient = scope.screenOrientation ? THREE.Math.degToRad(scope.screenOrientation) :
//			0; // O

      var orient = window.orientation ? THREE.Math.degToRad(window.orientation) :
        0; // O

		setObjectQuaternion(scope.object.quaternion, alpha, beta, gamma, orient);

	};

	this.dispose = function() {

		this.disconnect();

	};

	this.connect();

};
</script>
<style>
    body {
        color: #31708f !important;
    }
    canvas {
        width: 100%;
        height: 100%;
        padding: 0;
        margin: 0
    }
    .nopadding {
        padding: 0 !important;
        margin: 0 !important;
    }
</style>

<script src="js/three.min.js"></script>
<script src="js/StereoEffect.js"></script>
<script>

var m_effect


var m_mcontrols
  /*
   *主显区的长宽
   * */
var m_main_view_width, m_main_view_height;

var m_container, m_camera, m_scene, m_renderer;
var m_skybox = [],
  m_currentSkybox = "jd1";
/**
 * 初始化显区尺寸
 */

function updateSize() {
  m_main_view_width = window.innerWidth;
  m_main_view_height = window.innerHeight;
}
function init3D() {
  updateSize();
  // m_container = $("#3d_content");
  m_container = document.createElement('div');
  document.body.appendChild(m_container);
  m_camera = new THREE.PerspectiveCamera(75, m_main_view_width /m_main_view_height, 1, 1100);
  m_scene = new THREE.Scene();
  m_renderer = new THREE.WebGLRenderer({});
  m_renderer.setPixelRatio(window.devicePixelRatio);
  m_renderer.setSize(m_main_view_width, m_main_view_height);
  m_container.appendChild(m_renderer.domElement);
  window.addEventListener('resize', onWindowResize, false);
}

/**
 * 窗口尺寸变化处理器
 * */
function onWindowResize() {
  updateSize();
  m_effect.setSize(window.innerWidth, window.innerHeight);
  m_camera.aspect = window.innerWidth / window.innerHeight;
  m_camera.updateProjectionMatrix();

}






function animate() {
    requestAnimationFrame(animate);
    update();
}

function update() {
      m_mcontrols.update();
    m_effect.render( m_scene, m_camera );

}
function initSky(){
    var r3 = "texture/big_pic/";
    var urls3 = [
        r3 + "2048_RT.png", r3 + "2048_LF.png",
        r3 + "2048_UP.png", r3 + "2048_DN.png",
        r3 + "2048_BK.png", r3 + "2048_RF.png"
    ];
    var skytexture3=loadSkyTexture( urls3);
    skytexture3.jd_name="jd3";
    m_skybox.push(skytexture3);
    m_scene.add(buildSkyBox(skytexture3))

}

function loadSkyTexture(urls) {
  return new THREE.CubeTextureLoader().load(urls);
}

/**
 * 构建天空合，输入url数组，输出mesh
 */
function buildSkyBox(textureCube) {
  textureCube.format = THREE.RGBFormat;
  var shader = THREE.ShaderLib["cube"];
  shader.uniforms["tCube"].value = textureCube;
  var material = new THREE.ShaderMaterial({
    fragmentShader: shader.fragmentShader,
    vertexShader: shader.vertexShader,
    uniforms: shader.uniforms,
    depthWrite: false,
    side: THREE.BackSide
  })
  var mesh = new THREE.Mesh(new THREE.BoxGeometry(50, 50, 50), material);
  return mesh;
}

</script>
</head>
<body style="padding: 0;">
<script>
   init3D();
   initSky();
   m_effect= new THREE.StereoEffect( m_renderer );
   m_effect.setSize( window.innerWidth, window.innerHeight )
    m_mcontrols = new THREE.DeviceOrientationControls( m_camera );
   animate();
</script>
</body>
</html>
